"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = exports.onNewSocketConnected = exports.isSocketAuthenticated = exports.setResponseCookie = exports.checkForPermissionREST = exports.checkForPermission = exports.sockets = void 0;
var extendedLog_1 = require("./extendedLog");
var uuid_1 = require("uuid");
var types_ts_1 = require("@shared/types.ts");
var jwt = require("jsonwebtoken");
var cookie = require('cookie');
var SocketEntry = /** @class */ (function () {
    function SocketEntry(socket) {
        this.isLoggedIn = false;
        this.socket = socket;
    }
    return SocketEntry;
}());
var TokenEntry = /** @class */ (function () {
    function TokenEntry(token, expireInMS) {
        this.token = token;
        this.expireDate = new Date(Date.now() + expireInMS);
    }
    TokenEntry.prototype.isValid = function () { return Date.now() < this.expireDate.getTime(); };
    return TokenEntry;
}());
var AcceptTokenEntry = /** @class */ (function () {
    function AcceptTokenEntry(token, newClientSocketID, expireInMS) {
        this.token = token;
        this.newClientSocketID = newClientSocketID;
        this.expireDate = new Date(Date.now() + expireInMS);
    }
    AcceptTokenEntry.prototype.isValid = function () { return Date.now() < this.expireDate.getTime(); };
    return AcceptTokenEntry;
}());
// The name of the cookie that will be set via POST request in the browser:
var jwtCookieName = "keeper_jwt";
var jwtCookieAvailabliltyName = "keeper_jwt_presence";
exports.sockets = [];
// Token distributed in "device-token-granted" socket event.
var acceptTokens = [];
// Tokens that are generated by this server.
var generatedTokens = [];
// Tokens that are already confirmed to be logged-in
var validatedTokens = [];
// Not for production:
// Only for dev:
var correctPassword = "123";
var correctUsername = "123";
var siofu = require("socketio-file-upload");
var message = require("./message");
function checkForPermission(socketInstance) {
    var _a, _b, _c, _d;
    if (((_b = (_a = socketInstance === null || socketInstance === void 0 ? void 0 : socketInstance.request) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.cookie) == undefined) {
        socketInstance.emit("unauthorized", { error: "Missing cookie" });
        return false;
    }
    var authToken = cookie.parse((_d = (_c = socketInstance === null || socketInstance === void 0 ? void 0 : socketInstance.request) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d.cookie)[jwtCookieName];
    if (validatedTokens.find(function (x) { return x.token == authToken; }) == undefined) {
        socketInstance.emit("unauthorized", { error: "Invalid token" });
        return false;
    }
    if (!validatedTokens.find(function (x) { return x.token == authToken; }).isValid) {
        socketInstance.emit("unauthorized", { error: "Invalid token" });
        return false;
    }
    return true;
}
exports.checkForPermission = checkForPermission;
function checkForPermissionREST(request, response) {
    if (validatedTokens.find(function (x) { return x.token == request.cookies[jwtCookieName]; }) == undefined) {
        response.status(401).json({ error: "Invalid token" });
        return false;
    }
    return true;
}
exports.checkForPermissionREST = checkForPermissionREST;
function setResponseCookie(res, jwtToken, isSecure) {
    // Set cookie in browser:
    return res
        .cookie(jwtCookieName, jwtToken, {
        maxAge: 8.64e+7, secure: isSecure,
        sameSite: true, httpOnly: true,
    })
        // This cookie is for the client to check if jwt is presence, 
        // since the above cookie is not accessible by JS
        .cookie(jwtCookieAvailabliltyName, "true", {
        maxAge: 8.64e+7, secure: isSecure,
        sameSite: true, httpOnly: false,
    });
}
exports.setResponseCookie = setResponseCookie;
function isSocketAuthenticated(socketInstance) {
    var socketEntry = exports.sockets.find(function (x) { return x.socket.id == socketInstance.id; });
    if (socketEntry == undefined)
        return false;
    return socketEntry.isLoggedIn;
}
exports.isSocketAuthenticated = isSocketAuthenticated;
function onNewSocketConnected(socketInstance) {
    socketInstance.on("authentication", function () {
        var _a, _b;
        console.log("".concat(socketInstance.id, " trying to log in."));
        if (((_b = (_a = socketInstance === null || socketInstance === void 0 ? void 0 : socketInstance.request) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.cookie) == undefined)
            return socketInstance.emit("unauthorized", { error: "Missing cookie" });
        var token = cookie.parse(socketInstance.request.headers.cookie)[jwtCookieName];
        if (validatedTokens.find(function (x) { return x.token == token; }) != undefined) {
            exports.sockets.find(function (x) { return x.socket.id == socketInstance.id; }).isLoggedIn = true;
            console.log("socket ".concat(socketInstance.id, " logged-in."));
            // Broadcast connect event to all other sockets
            exports.sockets.forEach(function (soc) {
                if (soc.socket.id == socketInstance.id)
                    return; // Don't notify the newly joined socket itself
                soc.socket.emit("socket connect", { socketConnectedID: socketInstance.id });
            });
            // Allow file upload after successful login
            var uploader = new siofu();
            uploader.uploadValidator = function (event, callback) {
                if (checkForPermission(socketInstance))
                    callback(true);
                else {
                    callback(false);
                    console.log("".concat(socketInstance.id, " tried to upload file while not logged-in."));
                }
            };
            uploader.on("saved", function (event) {
                /*
                    Properties of event:
                    {
                        file:
                        {
                            name: 'scores.db',
                            mtime: 2023-06-08T10:25:23.660Z,
                            encoding: 'octet',
                            clientDetail: {},
                            meta: {},
                            id: 0,
                            size: 3177524,
                            bytesLoaded: 3177524,
                            success: true,
                            base: 'scores',
                            pathName: 'temp\\scores.db',
                            writeStream: WriteStream
                            {
                                fd: 3,
                                path: 'temp\\scores.db',
                                flags: 'w',
                                mode: '0666',
                                start: undefined,
                                pos: undefined,
                                bytesWritten: 3177524,
                                _writableState: [WritableState],
                                _events: [Object: null prototype],
                                _eventsCount: 2,
                                _maxListeners: undefined,
                                [Symbol(kFs)]: [Object],
                                [Symbol(kIsPerformingIO)]: false,
                                [Symbol(kCapture)]: false
                            }
                        }
                    }
                */
                // Broadcast connect event to all other sockets
                var fileUploadedName = event.file.pathName.split("\\").at(-1);
                var entry = new types_ts_1.FileMessageEntry(socketInstance.id, fileUploadedName, event.file.size);
                exports.sockets.forEach(function (soc) {
                    soc.socket.emit("file uploaded", entry);
                });
                message.allMessages.push(entry);
            });
            uploader.dir = "./temp";
            uploader.listen(socketInstance);
            return socketInstance.emit("authenticated");
        }
        else
            return socketInstance.emit("unauthorized", { error: "Token invalid" });
    });
    socketInstance.on("disconnect", function () {
        console.log("A socket ".concat(socketInstance.id, " disconnected."));
        exports.sockets = exports.sockets.filter(function (x) { return x.socket.id != socketInstance.id; });
        // Broadcast disconnect event to all sockets
        exports.sockets.forEach(function (soc) { soc.socket.emit("socket disconnect", { socketDisconnectedID: socketInstance.id }); });
    });
    // When the logged-in client accepts/scan the auth token.
    socketInstance.on("auth-device-token", function (data) {
        var _a, _b;
        try {
            if (((_b = (_a = socketInstance === null || socketInstance === void 0 ? void 0 : socketInstance.request) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.cookie) == undefined)
                throw new Error("The original account is not logged-in, thus cannot link new device.");
            if (checkForPermission(socketInstance)) {
                var jwtReceived = data.token;
                var payload = jwt.verify(jwtReceived, process.env.JWT_SECRET);
                var acceptToken = (0, uuid_1.v4)();
                acceptTokens.push(new AcceptTokenEntry(acceptToken, payload.clientSocketID, 60000));
                socketInstance.to(payload.clientSocketID).emit("device-token-granted", { token: acceptToken });
            }
        }
        catch (error) {
            console.log("Invalid JWT token received, error: ".concat(error, "."));
        }
    });
    socketInstance.on("request-device-token", function (data) {
        var jwtPayload = {
            clientSocketID: socketInstance.id,
            clientUserAgent: socketInstance.request.headers['user-agent'],
            salt: (0, uuid_1.v4)()
        };
        var jwtToken = jwt.sign(jwtPayload, process.env.JWT_SECRET, {
            expiresIn: 60, // seconds
        });
        socketInstance.emit("response request-device-token", { token: jwtToken });
        // jwt.sign({});
    });
}
exports.onNewSocketConnected = onNewSocketConnected;
function init(socketIOInstance, expressInstance, isRunningHTTPS) {
    socketIOInstance.on('connection', function (socket) {
        onNewSocketConnected(socket);
        exports.sockets.push(new SocketEntry(socket));
        console.log("new socket ".concat(socket.id, " connected, ").concat(exports.sockets.length));
    });
    expressInstance.post("/api/reset", function (req, res) {
        try {
            res.clearCookie(jwtCookieAvailabliltyName);
            res.clearCookie(jwtCookieName);
            res.status(200).json({});
        }
        catch (error) {
            res.status(500).json({});
        }
    });
    expressInstance.post("/api/accept-auth", function (req, res) {
        try {
            var acceptToken = req.body.token;
            var corrAcceptToken = acceptTokens.find(function (x) { return x.token == acceptToken; });
            if (corrAcceptToken == undefined)
                res.status(401).json({});
            else if (!corrAcceptToken.isValid())
                res.status(401).json({}); // token expired / invalid
            else // granted
             {
                var newToken = generateToken(true); // this token can be used to access protected resources
                setResponseCookie(res, newToken, isRunningHTTPS).status(200).json({});
            }
        }
        catch (error) {
            res.status(500).json({});
        }
    });
    expressInstance.post("/api/login/", function (req, res) {
        var username = req.body.username;
        var password = req.body.password;
        if (username !== correctUsername || password !== correctPassword) {
            res.status(401);
            res.json({});
        }
        else {
            var newToken = generateToken(true);
            setResponseCookie(res, newToken, isRunningHTTPS).status(200).json({});
        }
    });
    (0, extendedLog_1.logGreen)("Injected auth socket events.");
}
exports.init = init;
function generateToken(isValidated) {
    if (isValidated === void 0) { isValidated = false; }
    var newToken = (0, uuid_1.v4)();
    generatedTokens.push(new TokenEntry(newToken, 60000));
    if (isValidated)
        validatedTokens.push(new TokenEntry(newToken, 60000));
    return newToken;
}
